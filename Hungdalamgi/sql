-- 1. BẢNG PROFILES (Lưu thông tin người dùng, liên kết với Auth của Supabase)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  full_name TEXT,
  phone_number TEXT,
  address TEXT,
  role TEXT DEFAULT 'customer' CHECK (role IN ('customer', 'admin')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Trigger: Tự động tạo profile khi user đăng ký qua Supabase Auth
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', 'customer');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 2. BẢNG DANH MỤC
CREATE TABLE public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. BẢNG SẢN PHẨM (Thông tin chung)
CREATE TABLE public.products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category_id BIGINT REFERENCES public.categories(id),
  name TEXT NOT NULL,
  description TEXT,
  base_image_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. BẢNG BIẾN THỂ (Size, Hộp 50/100...)
CREATE TABLE public.product_variants (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
  sku TEXT UNIQUE,
  variant_name TEXT, -- VD: Hộp 50 ống
  price DECIMAL(15, 2) NOT NULL,
  stock_quantity INTEGER DEFAULT 0,
  image_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 5. BẢNG GIỎ HÀNG (Cart)
CREATE TABLE public.carts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE UNIQUE,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 6. BẢNG CHI TIẾT GIỎ HÀNG
CREATE TABLE public.cart_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cart_id BIGINT REFERENCES public.carts(id) ON DELETE CASCADE,
  variant_id BIGINT REFERENCES public.product_variants(id),
  quantity INTEGER DEFAULT 1,
  added_at TIMESTAMPTZ DEFAULT NOW()
);

-- 7. BẢNG ĐƠN HÀNG (Orders)
CREATE TABLE public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id), -- Link tới user
  
  -- Thông tin người nhận
  recipient_name TEXT NOT NULL,
  recipient_phone TEXT NOT NULL,
  shipping_address TEXT NOT NULL,
  
  -- Tiền nong
  total_amount DECIMAL(15, 2) NOT NULL,
  shipping_fee DECIMAL(15, 2) DEFAULT 0,
  final_amount DECIMAL(15, 2) NOT NULL,
  
  -- Trạng thái & Thanh toán
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'shipping', 'completed', 'cancelled')),
  payment_method TEXT DEFAULT 'cod',
  note TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 8. BẢNG CHI TIẾT ĐƠN HÀNG (Order Items)
CREATE TABLE public.order_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
  variant_id BIGINT REFERENCES public.product_variants(id),
  quantity INTEGER NOT NULL,
  price_at_purchase DECIMAL(15, 2) NOT NULL -- Lưu giá lúc mua
);

-- 9. BẢNG IMPACT STATS (Cho trang chủ)
CREATE TABLE public.impact_stats (
  stat_key TEXT PRIMARY KEY,
  stat_label TEXT,
  stat_value TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Dữ liệu mẫu cho Impact Stats
INSERT INTO public.impact_stats (stat_key, stat_label, stat_value) 
VALUES 
('straws_replaced', 'Ống hút thay thế', '40.000.000'),
('waste_reduced', 'Rác nhựa giảm', '20 Tấn');

---
--- PHẦN BẢO MẬT (ROW LEVEL SECURITY - RLS)
--- Bắt buộc bật cái này nếu không muốn User A nhìn thấy đơn hàng của User B
---

-- Bật RLS cho các bảng
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.carts ENABLE ROW LEVEL SECURITY;

-- 1. Chính sách cho Profiles: Ai xem được của người nấy (Admin xem hết)
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);
  
-- 2. Chính sách cho Sản phẩm: Ai cũng xem được (Public Read)
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public view products" ON public.products
  FOR SELECT USING (true);

-- 3. Chính sách cho Đơn hàng: User chỉ xem đơn của mình
CREATE POLICY "Users can view own orders" ON public.orders
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create orders" ON public.orders
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 4. Chính sách cho Giỏ hàng: Chỉ chủ sở hữu mới được đụng vào
CREATE POLICY "Users manage own cart" ON public.carts
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users manage own cart items" ON public.cart_items
  FOR ALL USING (
    cart_id IN (SELECT id FROM public.carts WHERE user_id = auth.uid())
  );






  ===================================================







  Đã rà soát schema Supabase của bạn. Kết luận và gợi ý như sau.

---

## Những phần ổn

- **profiles** gắn đúng với `auth.users(id)`, trigger tạo profile khi đăng ký hợp lý.
- **categories, products, product_variants**: cấu trúc và khóa ngoại đúng.
- **carts / cart_items**: một user một cart, quan hệ rõ ràng.
- **orders / order_items**: đủ thông tin nhận hàng, tiền, trạng thái.
- **impact_stats**: phù hợp cho số liệu trang chủ.
- RLS đã bật cho `profiles`, `orders`, `carts`, `products` và có policy cơ bản.

---

## Cần sửa / bổ sung

### 1. **RLS chưa bật cho `cart_items`**

Có policy nhưng chưa bật RLS trên bảng, nên policy không có tác dụng:

```sql
ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;
```

Sau đó giữ nguyên policy "Users manage own cart items" (điều kiện `cart_id IN (SELECT id FROM public.carts WHERE user_id = auth.uid())` là đúng).

---

### 2. **Policy cập nhật profile**

Hiện chỉ có SELECT. User cần sửa tên, SĐT, địa chỉ nên thêm UPDATE:

```sql
CREATE POLICY "Users can update own profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);
```

---

### 3. **Trigger cập nhật `profiles.updated_at`**

`updated_at` chỉ set lúc INSERT. Cần trigger khi UPDATE:

```sql
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
```

*(Nếu Supabase báo `EXECUTE PROCEDURE` thì dùng `EXECUTE PROCEDURE` thay cho `EXECUTE FUNCTION`.)*

---

### 4. **RLS cho `order_items`**

Không có RLS nên bất kỳ ai cũng có thể INSERT/SELECT/DELETE mọi `order_items`. Nên bật RLS và chỉ cho phép đọc/ghi khi đơn thuộc user:

```sql
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;

-- User chỉ xem / thêm item vào đơn của chính mình
CREATE POLICY "Users can view own order_items" ON public.order_items
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.orders WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid())
  );

CREATE POLICY "Users can insert own order_items" ON public.order_items
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM public.orders WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid())
  );
```

*(Thường app chỉ insert order_items lúc checkout, không cho user xóa/sửa sau; nếu cần có thể thêm UPDATE/DELETE với cùng điều kiện.)*

---

### 5. **RLS cho `categories` và `product_variants`**

Hai bảng này chưa RLS → cả anonymous đều có thể đọc/ghi. Nên bật RLS và cho phép mọi người chỉ đọc:

```sql
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read categories" ON public.categories
  FOR SELECT USING (true);

ALTER TABLE public.product_variants ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read product_variants" ON public.product_variants
  FOR SELECT USING (true);
```

Khi đó chỉ service role (hoặc admin qua Dashboard / function) mới INSERT/UPDATE/DELETE categories và product_variants.

---

### 6. **RLS cho `impact_stats`**

Tương tự, nên hạn chế ghi:

```sql
ALTER TABLE public.impact_stats ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read impact_stats" ON public.impact_stats
  FOR SELECT USING (true);
```

Chỉ admin/service role cập nhật số liệu.

---

### 7. **Policy “Admin xem hết” cho profiles**

Bạn ghi “Admin xem hết” nhưng policy hiện tại chỉ cho `auth.uid() = id`. Để admin xem mọi profile cần có role trong `profiles` và policy kiểu:

```sql
-- Ví dụ: admin là role trong profiles
CREATE POLICY "Admin can view all profiles" ON public.profiles
  FOR SELECT USING (
    (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'
  );
```

Hoặc dùng một bảng quyền riêng. Hiện tại nếu chưa có cơ chế admin thì có thể bỏ qua, chỉ cần “Users can view own profile” + “Users can update own profile”.

---

## Tùy chọn (không bắt buộc)

- **orders.payment_method**: nếu muốn chặt, thêm  
  `CHECK (payment_method IN ('cod', 'banking', 'momo'))`.
- **orders.discount_amount**: nếu sau này dùng mã giảm giá, thêm cột `discount_amount DECIMAL(15,2) DEFAULT 0`.
- **Bảng Coupons**: schema hiện không có; khi cần có thể thêm sau giống thiết kế cũ (code, discount_type, discount_value, start_date, end_date, usage_limit, is_active).

---

## Tóm tắt thứ tự thao tác trên Supabase

1. Bật RLS cho `cart_items` (và giữ policy hiện tại).
2. Thêm policy “Users can update own profile” cho `profiles`.
3. Tạo function + trigger `set_updated_at` cho `profiles.updated_at`.
4. Bật RLS cho `order_items` và thêm policy SELECT + INSERT theo `orders.user_id = auth.uid()`.
5. Bật RLS cho `categories`, `product_variants`, `impact_stats` và thêm policy SELECT cho public (nếu muốn bảo vệ không cho anonymous/guest ghi).

Làm xong các bước trên thì schema vừa khớp nghiệp vụ vừa bảo mật đúng với Supabase (RLS + Auth).




=================================================================

Chào bạn, tôi đã xem xét kỹ đoạn code SQL và phần đánh giá đi kèm mà bạn cung cấp.

**Nhận định nhanh:** Phần đánh giá (từ đoạn `===` trở xuống) mà bạn dán vào **đã rất chính xác về mặt bảo mật (RLS) và tính năng cơ bản**. Nếu bạn làm theo các bước đó, hệ thống sẽ chạy ổn.

Tuy nhiên, để hệ thống **"Production-ready"** (chạy thực tế mượt mà, không mất dữ liệu quan trọng và nhanh hơn), tôi phát hiện thêm **3 vấn đề tiềm ẩn** mà phần đánh giá trước đó chưa đề cập tới.

Dưới đây là chi tiết và cách khắc phục:

---

### 1. Vấn đề an toàn dữ liệu: Xóa User mất luôn Đơn Hàng (Nguy hiểm)

Trong bảng `orders`, bạn đang để:

```sql
user_id UUID REFERENCES public.profiles(id) -- Mặc định Supabase/Postgres không set gì thì thôi

```

Tuy nhiên, nếu bạn để ràng buộc mặc định hoặc lỡ tay thêm `ON DELETE CASCADE` (giống bảng `profiles` reference `auth.users`), khi một user bị xóa (hoặc user tự xóa tài khoản), **toàn bộ lịch sử đơn hàng của họ sẽ biến mất**.
=> **Kế toán/Admin sẽ bị lệch số liệu doanh thu.**

**Khắc phục:**
Đơn hàng là dữ liệu tài chính, phải được giữ lại dù user có mất đi. Hãy sửa lại ràng buộc này thành `SET NULL` hoặc bỏ `CASCADE`.

```sql
-- Sửa bảng orders (nếu chưa tạo thì sửa trong CREATE TABLE, nếu tạo rồi thì chạy lệnh này)
ALTER TABLE public.orders
DROP CONSTRAINT IF EXISTS orders_user_id_fkey,
ADD CONSTRAINT orders_user_id_fkey
  FOREIGN KEY (user_id)
  REFERENCES public.profiles(id)
  ON DELETE SET NULL; -- User xóa thì đơn hàng vẫn còn, chỉ mất link tới user

```

---

### 2. Vấn đề hiệu năng: Thiếu Index cho Khóa Ngoại (Foreign Keys)

Supabase (PostgreSQL) tự động đánh index cho `PRIMARY KEY`, nhưng **không tự đánh index cho `FOREIGN KEY**`.
Khi dữ liệu lớn lên (ví dụ: 10.000 sản phẩm, 5.000 đơn hàng):

* Query "Lấy tất cả sản phẩm thuộc danh mục X" sẽ chậm.
* Query "Lấy tất cả chi tiết đơn hàng của Order Y" sẽ chậm.

**Khắc phục:** Chạy thêm các lệnh tạo Index sau:

```sql
-- Tăng tốc tìm sản phẩm theo danh mục
CREATE INDEX idx_products_category ON public.products(category_id);

-- Tăng tốc tìm biến thể theo sản phẩm
CREATE INDEX idx_variants_product ON public.product_variants(product_id);

-- Tăng tốc load giỏ hàng
CREATE INDEX idx_cart_items_cart ON public.cart_items(cart_id);
CREATE INDEX idx_cart_items_variant ON public.cart_items(variant_id);

-- Tăng tốc load lịch sử đơn hàng của user
CREATE INDEX idx_orders_user ON public.orders(user_id);

-- Tăng tốc load chi tiết đơn hàng
CREATE INDEX idx_order_items_order ON public.order_items(order_id);

```

---

### 3. Tối ưu UX: Tự động tạo Giỏ hàng (Cart)

Hiện tại trigger `handle_new_user` chỉ tạo `profile`.
Khi user login lần đầu, bảng `carts` chưa có dữ liệu. Frontend sẽ phải check: *Có cart chưa? Chưa thì tạo -> Rồi mới lấy item.* Việc này làm code frontend phức tạp và chậm.

**Khắc phục:** Tự động tạo luôn cái Cart rỗng ngay khi User đăng ký. Sửa lại trigger `handle_new_user`:

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- 1. Tạo Profile
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', 'customer');

  -- 2. Tạo luôn Cart rỗng cho user này
  INSERT INTO public.carts (user_id)
  VALUES (new.id);

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

```

---

### Tổng hợp các bước bạn cần làm ngay (Action Plan)

Dựa trên code gốc và các bổ sung, đây là checklist hoàn chỉnh nhất để bạn chạy trong **SQL Editor** của Supabase:

1. **Chạy Schema gốc** (từ code bạn cung cấp).
2. **Chạy bản vá RLS** (từ phần đánh giá bạn cung cấp: bật RLS cho `cart_items`, `order_items`, `categories`, v.v.).
3. **Chạy bản vá Hiệu năng & An toàn** (tôi vừa cung cấp ở trên: Index và FK constraints).
4. **Cập nhật Trigger** (để tự tạo cart).

**Bạn có muốn tôi gộp tất cả các sửa đổi này vào một file SQL duy nhất hoàn chỉnh để bạn chỉ việc Copy-Paste một lần không?**